# -*- coding: utf-8 -*-
"""Scentific Report cryptograhy part

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FSNr6saWxxxJRFILr5uJYruWx_5YC9Ej
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Algorithm"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft2
import hashlib
from typing import Tuple, List, Dict
import time


class AdvancedImageEncryption:
    """
    Lossless multi-layer image encryption for COLOR images with perfect reconstruction.
    Processes each channel (R, G, B) independently.
    """

    def __init__(self, password: str):
        self.password = password
        self.key_hash = hashlib.sha256(password.encode()).digest()
        self.chaos_params = self._derive_chaos_parameters()

        # DNA tables (2 bits/base)
        self.dna_table = {0: 'A', 1: 'T', 2: 'G', 3: 'C'}
        self.reverse_dna_table = {v: k for k, v in self.dna_table.items()}

    def _derive_chaos_parameters(self) -> Dict[str, float]:
        hv = [int.from_bytes(self.key_hash[i:i + 4], 'big') for i in range(0, 32, 4)]
        return {
            'x0': (hv[0] % 10000) / 10000.0 or 0.1234,
            'y0': (hv[1] % 10000) / 10000.0 or 0.5678,
            'r': 3.9 + (hv[2] % 1000) / 10000.0,
            'a': 1.4 + (hv[3] % 1000) / 10000.0,
            'b': 0.3 + (hv[4] % 1000) / 100000.0,
            'seed': hv[5] % (2**32),
        }

    def generate_chaotic_sequence(self, length: int) -> np.ndarray:
        x, y = self.chaos_params['x0'], self.chaos_params['y0']
        r, a, b = self.chaos_params['r'], self.chaos_params['a'], self.chaos_params['b']
        seq = np.empty(length, dtype=np.float64)
        for i in range(length):
            x_new = r * x * (1.0 - x)
            y_new = 1.0 - a * y * y + b * x
            x, y = (x_new + 0.1 * y_new) % 1.0, (y_new + 0.1 * x_new) % 1.0
            seq[i] = (x + y) * 0.5
        return seq

    def fractal_permutation(self, matrix: np.ndarray, max_iter: int = 50) -> np.ndarray:
        h, w = matrix.shape[:2]
        xs = np.linspace(-2.5, 1.5, w)
        ys = np.linspace(-1.25, 1.25, h)
        X, Y = np.meshgrid(xs, ys)
        C = X + 1j * Y

        Z = np.zeros_like(C, dtype=np.complex128)
        escaped = np.zeros(C.shape, dtype=bool)
        escape_iter = np.full(C.shape, max_iter, dtype=np.int32)

        for i in range(max_iter):
            mask = ~escaped & (np.abs(Z) <= 2.0)
            Z[mask] = Z[mask] * Z[mask] + C[mask]
            still_in = (np.abs(Z) <= 2.0)
            newly_escaped = (~still_in) & (~escaped)
            escape_iter[newly_escaped] = i
            escaped |= newly_escaped

        flat = escape_iter.ravel()
        perm_indices = np.argsort(flat, kind='mergesort')
        return perm_indices

    def dna_encode(self, data: np.ndarray) -> List[str]:
        dna_sequence: List[str] = []
        flat = data.ravel()
        for pix in flat:
            val = int(pix)
            for i in range(4):
                base_val = (val >> (2 * i)) & 3
                dna_sequence.append(self.dna_table[base_val])
        return dna_sequence

    def dna_decode(self, dna_sequence: List[str], shape: Tuple[int, ...]) -> np.ndarray:
        expected_pixels = int(np.prod(shape))
        pixels: List[int] = []
        upto = min(len(dna_sequence), expected_pixels * 4)
        for i in range(0, upto, 4):
            pix = 0
            for j in range(4):
                pix |= (self.reverse_dna_table[dna_sequence[i + j]] << (2 * j))
            pixels.append(pix)
        if len(pixels) < expected_pixels:
            pixels.extend([0] * (expected_pixels - len(pixels)))
        pixels = pixels[:expected_pixels]
        return np.asarray(pixels, dtype=np.uint8).reshape(shape)

    @staticmethod
    def _mat2x2_mul(M: Tuple[int, int, int, int], v0: int, v1: int) -> Tuple[int, int]:
        m00, m01, m10, m11 = M
        t0 = (m00 * v0 + m01 * v1) & 0xFFFF
        t1 = (m10 * v0 + m11 * v1) & 0xFFFF
        return (t0 % 256, t1 % 256)

    @staticmethod
    def _make_unimodular_k(x: float) -> int:
        k = int(x * 255.0) | 1
        return k

    @staticmethod
    def _build_M_and_inv(k: int) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int]]:
        k2 = (k * k) % 256
        M = (1 % 256, k % 256, k % 256, (1 + k2) % 256)
        Minv = ((1 + k2) % 256, (-k) % 256, (-k) % 256, 1 % 256)
        return M, Minv

    def block_mix(self, img: np.ndarray, chaos_seq: np.ndarray) -> np.ndarray:
        h, w = img.shape
        res = img.copy().astype(np.uint8)
        blocks_w = w // 2
        blocks_h = h // 2

        for bi in range(blocks_h):
            for bj in range(blocks_w):
                i = 2 * bi
                j = 2 * bj
                idx = (bi * blocks_w + bj) % len(chaos_seq)
                k = self._make_unimodular_k(chaos_seq[idx])
                M, _ = self._build_M_and_inv(k)

                a, b = int(res[i, j]), int(res[i, j + 1])
                c, d = int(res[i + 1, j]), int(res[i + 1, j + 1])

                a2, b2 = self._mat2x2_mul(M, a, b)
                c2, d2 = self._mat2x2_mul(M, c, d)

                col0_top, col0_bot = self._mat2x2_mul(M, a2, c2)
                col1_top, col1_bot = self._mat2x2_mul(M, b2, d2)

                res[i, j] = col0_top
                res[i + 1, j] = col0_bot
                res[i, j + 1] = col1_top
                res[i + 1, j + 1] = col1_bot

        return res

    def block_unmix(self, img: np.ndarray, chaos_seq: np.ndarray) -> np.ndarray:
        h, w = img.shape
        res = img.copy().astype(np.uint8)
        blocks_w = w // 2
        blocks_h = h // 2

        for bi in range(blocks_h):
            for bj in range(blocks_w):
                i = 2 * bi
                j = 2 * bj
                idx = (bi * blocks_w + bj) % len(chaos_seq)
                k = self._make_unimodular_k(chaos_seq[idx])
                M, Minv = self._build_M_and_inv(k)

                a, b = int(res[i, j]), int(res[i, j + 1])
                c, d = int(res[i + 1, j]), int(res[i + 1, j + 1])

                a2, c2 = self._mat2x2_mul(Minv, a, c)
                b2, d2 = self._mat2x2_mul(Minv, b, d)

                a3, b3 = self._mat2x2_mul(Minv, a2, b2)
                c3, d3 = self._mat2x2_mul(Minv, c2, d2)

                res[i, j] = a3
                res[i, j + 1] = b3
                res[i + 1, j] = c3
                res[i + 1, j + 1] = d3

        return res

    def elliptic_curve_key_generation(self, size: int) -> np.ndarray:
        rng = np.random.default_rng(self.chaos_params['seed'])
        keys = np.empty(size, dtype=np.uint8)
        for i in range(size):
            hv = hashlib.sha256(f"{i}:{self.chaos_params['x0']}:{self.chaos_params['y0']}".encode()).digest()
            keys[i] = (hv[i % 32] ^ rng.integers(0, 256, dtype=np.uint8)).item()
        return keys

    def encrypt_channel(self, channel: np.ndarray, chaos_seq: np.ndarray, perm_indices: np.ndarray) -> np.ndarray:
        """Encrypt a single channel"""
        work = channel.copy().astype(np.uint8)

        # Fractal permutation
        work = work.ravel()[perm_indices].reshape(work.shape)

        # DNA encode + shuffle
        dna_seq = self.dna_encode(work)
        order = np.argsort(chaos_seq[:len(dna_seq)], kind='mergesort')
        shuffled_dna = [dna_seq[i] for i in order]
        work = self.dna_decode(shuffled_dna, work.shape)

        # Block mixing
        work = self.block_mix(work, chaos_seq)

        # XOR diffusion
        keys = self.elliptic_curve_key_generation(work.size)
        encrypted = np.bitwise_xor(work.ravel(), keys).reshape(work.shape).astype(np.uint8)

        return encrypted, order

    def decrypt_channel(self, encrypted_channel: np.ndarray, chaos_seq: np.ndarray,
                       perm_indices: np.ndarray, dna_order: np.ndarray) -> np.ndarray:
        """Decrypt a single channel"""
        # XOR
        keys = self.elliptic_curve_key_generation(encrypted_channel.size)
        work = np.bitwise_xor(encrypted_channel.ravel(), keys).reshape(encrypted_channel.shape).astype(np.uint8)

        # Block unmix
        work = self.block_unmix(work, chaos_seq)

        # DNA unshuffle + decode
        dna_seq = self.dna_encode(work)
        original_dna = ['A'] * len(dna_seq)
        for i, idx in enumerate(dna_order):
            original_dna[int(idx)] = dna_seq[i]
        work = self.dna_decode(original_dna, encrypted_channel.shape)

        # Inverse permutation
        inv_perm = np.argsort(perm_indices, kind='mergesort')
        work = work.ravel()[inv_perm].reshape(encrypted_channel.shape)

        return work.astype(np.uint8)

    def encrypt_image(self, image: np.ndarray) -> Tuple[np.ndarray, Dict]:
        """Encrypt color image - process each channel independently"""
        print("Starting advanced multi-layer encryption for COLOR image...")

        if image.ndim == 2:
            # Convert grayscale to 3-channel
            image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)

        original_shape = image.shape
        print(f"Processing color image of size: {original_shape}")

        h, w, c = image.shape

        # Generate shared chaotic sequence and permutation
        print("Generating chaotic sequences and permutation...")
        chaos_seq = self.generate_chaotic_sequence(h * w * 4)
        perm_indices = self.fractal_permutation(image[:, :, 0])  # Use same permutation for all channels

        # Encrypt each channel
        encrypted_channels = []
        dna_orders = []

        for ch in range(c):
            print(f"Encrypting channel {ch + 1}/{c}...")
            enc_ch, order = self.encrypt_channel(image[:, :, ch], chaos_seq, perm_indices)
            encrypted_channels.append(enc_ch)
            dna_orders.append(order)

        encrypted = np.stack(encrypted_channels, axis=2)

        params = {
            'perm_indices': perm_indices,
            'dna_orders': dna_orders,
            'chaos_seq': chaos_seq,
            'original_shape': original_shape,
        }

        print("Encryption completed!")
        return encrypted, params

    def decrypt_image(self, encrypted_image: np.ndarray, params: Dict) -> np.ndarray:
        """Decrypt color image - process each channel independently"""
        print("Starting decryption process for COLOR image...")

        chaos_seq = params['chaos_seq']
        perm_indices = params['perm_indices']
        dna_orders = params['dna_orders']

        h, w, c = encrypted_image.shape

        # Decrypt each channel
        decrypted_channels = []

        for ch in range(c):
            print(f"Decrypting channel {ch + 1}/{c}...")
            dec_ch = self.decrypt_channel(encrypted_image[:, :, ch], chaos_seq,
                                         perm_indices, dna_orders[ch])
            decrypted_channels.append(dec_ch)

        decrypted = np.stack(decrypted_channels, axis=2)

        print("Decryption completed!")
        return decrypted.astype(np.uint8)


def analyze_encryption_security(original: np.ndarray, encrypted: np.ndarray) -> dict:
    """Security analysis for color images"""
    print("Analyzing encryption security...")

    def correlation_coefficient(x, y):
        return float(np.corrcoef(x.ravel(), y.ravel())[0, 1])

    def entropy(image):
        hist, _ = np.histogram(image, bins=256, range=(0, 256))
        hist = hist[hist > 0]
        prob = hist / np.sum(hist)
        return float(-np.sum(prob * np.log2(prob)))

    def npcr(img1, img2):
        diff = np.count_nonzero(img1 != img2)
        return float(diff / img1.size * 100.0)

    def uaci(img1, img2):
        diff = np.abs(img1.astype(np.float64) - img2.astype(np.float64))
        return float(np.mean(diff) / 255.0 * 100.0)

    return {
        'correlation': abs(correlation_coefficient(original, encrypted)),
        'entropy_original': entropy(original),
        'entropy_encrypted': entropy(encrypted),
        'npcr': npcr(original, encrypted),
        'uaci': uaci(original, encrypted),
        'mean_original': float(np.mean(original)),
        'mean_encrypted': float(np.mean(encrypted)),
        'std_original': float(np.std(original)),
        'std_encrypted': float(np.std(encrypted)),
    }


def plot_comprehensive_analysis(original, encrypted, decrypted, metrics, enc_time, dec_time):
    """Visualization for color images"""
    fig, axes = plt.subplots(3, 4, figsize=(20, 15))

    # Convert BGR to RGB for display
    original_rgb = cv2.cvtColor(original, cv2.COLOR_BGR2RGB)
    encrypted_rgb = cv2.cvtColor(encrypted, cv2.COLOR_BGR2RGB)
    decrypted_rgb = cv2.cvtColor(decrypted, cv2.COLOR_BGR2RGB)

    # Row 1: Images
    axes[0, 0].imshow(original_rgb)
    axes[0, 0].set_title('Original')
    axes[0, 0].axis('off')

    axes[0, 1].imshow(encrypted_rgb)
    axes[0, 1].set_title(f'Encrypted\n({enc_time:.3f}s)')
    axes[0, 1].axis('off')

    axes[0, 2].imshow(decrypted_rgb)
    axes[0, 2].set_title(f'Decrypted\n({dec_time:.3f}s)')
    axes[0, 2].axis('off')

    diff = np.abs(original.astype(float) - decrypted.astype(float))
    axes[0, 3].imshow(diff.astype(np.uint8))
    axes[0, 3].set_title(f'Diff (MSE: {np.mean(diff**2):.8f})')
    axes[0, 3].axis('off')

    # Row 2: Histograms (per channel)
    colors = ['red', 'green', 'blue']
    for i, color in enumerate(colors):
        axes[1, 0].hist(original[:, :, i].ravel(), bins=256, alpha=0.5, color=color, label=color.upper())
        axes[1, 1].hist(encrypted[:, :, i].ravel(), bins=256, alpha=0.5, color=color)
        axes[1, 2].hist(decrypted[:, :, i].ravel(), bins=256, alpha=0.5, color=color)

    axes[1, 0].set_title('Original Histograms')
    axes[1, 0].legend()
    axes[1, 1].set_title('Encrypted Histograms')
    axes[1, 2].set_title('Decrypted Histograms')

    # Uniformity test
    hist_enc, _ = np.histogram(encrypted.ravel(), bins=256, range=(0, 256))
    expected = np.mean(hist_enc) if np.mean(hist_enc) > 0 else 1.0
    chi_square = float(np.sum((hist_enc - expected) ** 2 / expected))
    axes[1, 3].bar(range(len(hist_enc)), hist_enc)
    axes[1, 3].axhline(y=expected, linestyle='--', color='r')
    axes[1, 3].set_title(f'Uniformity (χ²={chi_square:.2f})')

    # Row 3: Additional analysis
    # Timing comparison
    axes[2, 0].bar(['Encryption', 'Decryption'], [enc_time, dec_time], color=['#ff6b6b', '#4ecdc4'])
    axes[2, 0].set_ylabel('Time (seconds)')
    axes[2, 0].set_title('Processing Time')
    axes[2, 0].grid(axis='y', alpha=0.3)

    # Security metrics
    metric_names = list(metrics.keys())
    metric_values = list(metrics.values())
    axes[2, 1].barh(metric_names, metric_values)
    axes[2, 1].set_title('Security Metrics')
    axes[2, 1].set_xlabel('Value')

    # Correlation scatter
    rng = np.random.default_rng(42)
    sample_size = min(5000, original.size)
    idx = rng.choice(original.size, sample_size, replace=False)
    axes[2, 2].scatter(original.ravel()[idx], encrypted.ravel()[idx], alpha=0.3, s=1, c='purple')
    axes[2, 2].set_title(f'Correlation (r={metrics["correlation"]:.6f})')
    axes[2, 2].set_xlabel('Original')
    axes[2, 2].set_ylabel('Encrypted')
    axes[2, 2].grid(True, alpha=0.3)

    # Channel-wise MSE
    mse_per_channel = [np.mean((original[:, :, i].astype(float) - decrypted[:, :, i].astype(float))**2)
                       for i in range(3)]
    axes[2, 3].bar(['Red', 'Green', 'Blue'], mse_per_channel, color=['red', 'green', 'blue'])
    axes[2, 3].set_ylabel('MSE')
    axes[2, 3].set_title('Reconstruction Error per Channel')
    axes[2, 3].grid(axis='y', alpha=0.3)

    plt.tight_layout()
    plt.savefig('encryption_analysis.png', dpi=150, bbox_inches='tight')
    print("Analysis plot saved as 'encryption_analysis.png'")
    plt.show()


def main():
    # Load a color image - replace with your image path
    try:
        # Try to load from file
        image = cv2.imread('/content/Test.jpg')  # Replace with your image path
        if image is None:
            print("Creating synthetic test image...")
            # Create a colorful test image
            h, w = 256, 256
            image = np.zeros((h, w, 3), dtype=np.uint8)
            # Create gradient patterns
            for i in range(h):
                for j in range(w):
                    image[i, j, 0] = int((i / h) * 255)  # Red channel
                    image[i, j, 1] = int((j / w) * 255)  # Green channel
                    image[i, j, 2] = int(((i + j) / (h + w)) * 255)  # Blue channel
            # Add some shapes
            cv2.circle(image, (w//2, h//2), 50, (255, 255, 0), -1)
            cv2.rectangle(image, (w//4, h//4), (3*w//4, 3*h//4), (0, 255, 255), 3)
    except Exception as e:
        print(f"Error loading image: {e}")
        print("Creating synthetic test image...")
        h, w = 256, 256
        image = np.zeros((h, w, 3), dtype=np.uint8)
        for i in range(h):
            for j in range(w):
                image[i, j] = [int((i/h)*255), int((j/w)*255), int(((i+j)/(h+w))*255)]

    print(f"Processing color image with shape: {image.shape}, dtype={image.dtype}")

    # Initialize encryptor
    encryptor = AdvancedImageEncryption("SecureTestPassword2024!")

    # ENCRYPTION
    print("\n" + "="*60)
    print("ENCRYPTION PHASE")
    print("="*60)
    t_enc_start = time.time()
    encrypted, params = encryptor.encrypt_image(image)
    t_enc_end = time.time()
    encryption_time = t_enc_end - t_enc_start

    # DECRYPTION
    print("\n" + "="*60)
    print("DECRYPTION PHASE")
    print("="*60)
    t_dec_start = time.time()
    decrypted = encryptor.decrypt_image(encrypted, params)
    t_dec_end = time.time()
    decryption_time = t_dec_end - t_dec_start

    # TIMING RESULTS
    print("\n" + "="*60)
    print("TIMING ANALYSIS")
    print("="*60)
    print(f"Encryption time: {encryption_time:.6f} seconds")
    print(f"Decryption time: {decryption_time:.6f} seconds")
    print(f"Total time: {encryption_time + decryption_time:.6f} seconds")
    print(f"Throughput (encryption): {image.size / encryption_time / 1e6:.3f} Mpixels/sec")
    print(f"Throughput (decryption): {image.size / decryption_time / 1e6:.3f} Mpixels/sec")

    # RECONSTRUCTION QUALITY
    print("\n" + "="*60)
    print("RECONSTRUCTION QUALITY")
    print("="*60)
    diff = image.astype(np.int16) - decrypted.astype(np.int16)
    mse = float(np.mean((diff.astype(np.float64)) ** 2))
    max_diff = int(np.max(np.abs(diff)))
    perfect = (mse == 0.0 and max_diff == 0)

    print(f"MSE: {mse:.10f}")
    print(f"Max absolute difference: {max_diff}")
    print(f"Perfect reconstruction: {perfect}")

    if perfect:
        print("✅ PERFECT DECRYPTION ACHIEVED!")
    else:
        print("❌ Decryption discrepancy detected")
        print(f"Number of different pixels: {np.count_nonzero(image != decrypted)}")
        # Per-channel analysis
        for ch, color in enumerate(['Red', 'Green', 'Blue']):
            ch_diff = np.count_nonzero(image[:, :, ch] != decrypted[:, :, ch])
            print(f"  {color} channel: {ch_diff} different pixels")

    # SECURITY ANALYSIS
    print("\n" + "="*60)
    print("SECURITY ANALYSIS")
    print("="*60)
    metrics = analyze_encryption_security(image, encrypted)
    for k, v in metrics.items():
        print(f"{k}: {v:.6f}")

    # SAVE IMAGES
    print("\n" + "="*60)
    print("SAVING RESULTS")
    print("="*60)
    cv2.imwrite('original_color.png', image)
    cv2.imwrite('encrypted_color.png', encrypted)
    cv2.imwrite('decrypted_color.png', decrypted)
    print("✅ Original image saved as: original_color.png")
    print("✅ Encrypted image saved as: encrypted_color.png")
    print("✅ Decrypted image saved as: decrypted_color.png")

    # VISUALIZATION
    print("\n" + "="*60)
    print("GENERATING ANALYSIS PLOTS")
    print("="*60)
    plot_comprehensive_analysis(image, encrypted, decrypted, metrics, encryption_time, decryption_time)

    return image, encrypted, decrypted, metrics, encryption_time, decryption_time


if __name__ == "__main__":
    original, encrypted, decrypted, metrics, enc_time, dec_time = main()

"""# RObustness analysis"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft2
import hashlib
from typing import Tuple, List, Dict
import time
from io import BytesIO
from PIL import Image


class AdvancedImageEncryption:
    """
    Lossless multi-layer image encryption for COLOR images with perfect reconstruction.
    Processes each channel (R, G, B) independently.
    """

    def __init__(self, password: str):
        self.password = password
        self.key_hash = hashlib.sha256(password.encode()).digest()
        self.chaos_params = self._derive_chaos_parameters()
        self.dna_table = {0: 'A', 1: 'T', 2: 'G', 3: 'C'}
        self.reverse_dna_table = {v: k for k, v in self.dna_table.items()}

    def _derive_chaos_parameters(self) -> Dict[str, float]:
        hv = [int.from_bytes(self.key_hash[i:i + 4], 'big') for i in range(0, 32, 4)]
        return {
            'x0': (hv[0] % 10000) / 10000.0 or 0.1234,
            'y0': (hv[1] % 10000) / 10000.0 or 0.5678,
            'r': 3.9 + (hv[2] % 1000) / 10000.0,
            'a': 1.4 + (hv[3] % 1000) / 10000.0,
            'b': 0.3 + (hv[4] % 1000) / 100000.0,
            'seed': hv[5] % (2**32),
        }

    def generate_chaotic_sequence(self, length: int) -> np.ndarray:
        x, y = self.chaos_params['x0'], self.chaos_params['y0']
        r, a, b = self.chaos_params['r'], self.chaos_params['a'], self.chaos_params['b']
        seq = np.empty(length, dtype=np.float64)
        for i in range(length):
            x_new = r * x * (1.0 - x)
            y_new = 1.0 - a * y * y + b * x
            x, y = (x_new + 0.1 * y_new) % 1.0, (y_new + 0.1 * x_new) % 1.0
            seq[i] = (x + y) * 0.5
        return seq

    def fractal_permutation(self, matrix: np.ndarray, max_iter: int = 50) -> np.ndarray:
        h, w = matrix.shape[:2]
        xs = np.linspace(-2.5, 1.5, w)
        ys = np.linspace(-1.25, 1.25, h)
        X, Y = np.meshgrid(xs, ys)
        C = X + 1j * Y
        Z = np.zeros_like(C, dtype=np.complex128)
        escaped = np.zeros(C.shape, dtype=bool)
        escape_iter = np.full(C.shape, max_iter, dtype=np.int32)
        for i in range(max_iter):
            mask = ~escaped & (np.abs(Z) <= 2.0)
            Z[mask] = Z[mask] * Z[mask] + C[mask]
            still_in = (np.abs(Z) <= 2.0)
            newly_escaped = (~still_in) & (~escaped)
            escape_iter[newly_escaped] = i
            escaped |= newly_escaped
        flat = escape_iter.ravel()
        perm_indices = np.argsort(flat, kind='mergesort')
        return perm_indices

    def dna_encode(self, data: np.ndarray) -> List[str]:
        dna_sequence: List[str] = []
        flat = data.ravel()
        for pix in flat:
            val = int(pix)
            for i in range(4):
                base_val = (val >> (2 * i)) & 3
                dna_sequence.append(self.dna_table[base_val])
        return dna_sequence

    def dna_decode(self, dna_sequence: List[str], shape: Tuple[int, ...]) -> np.ndarray:
        expected_pixels = int(np.prod(shape))
        pixels: List[int] = []
        upto = min(len(dna_sequence), expected_pixels * 4)
        for i in range(0, upto, 4):
            pix = 0
            for j in range(4):
                pix |= (self.reverse_dna_table[dna_sequence[i + j]] << (2 * j))
            pixels.append(pix)
        if len(pixels) < expected_pixels:
            pixels.extend([0] * (expected_pixels - len(pixels)))
        pixels = pixels[:expected_pixels]
        return np.asarray(pixels, dtype=np.uint8).reshape(shape)

    @staticmethod
    def _mat2x2_mul(M: Tuple[int, int, int, int], v0: int, v1: int) -> Tuple[int, int]:
        m00, m01, m10, m11 = M
        t0 = (m00 * v0 + m01 * v1) & 0xFFFF
        t1 = (m10 * v0 + m11 * v1) & 0xFFFF
        return (t0 % 256, t1 % 256)

    @staticmethod
    def _make_unimodular_k(x: float) -> int:
        k = int(x * 255.0) | 1
        return k

    @staticmethod
    def _build_M_and_inv(k: int) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int]]:
        k2 = (k * k) % 256
        M = (1 % 256, k % 256, k % 256, (1 + k2) % 256)
        Minv = ((1 + k2) % 256, (-k) % 256, (-k) % 256, 1 % 256)
        return M, Minv

    def block_mix(self, img: np.ndarray, chaos_seq: np.ndarray) -> np.ndarray:
        h, w = img.shape
        res = img.copy().astype(np.uint8)
        blocks_w = w // 2
        blocks_h = h // 2
        for bi in range(blocks_h):
            for bj in range(blocks_w):
                i = 2 * bi
                j = 2 * bj
                idx = (bi * blocks_w + bj) % len(chaos_seq)
                k = self._make_unimodular_k(chaos_seq[idx])
                M, _ = self._build_M_and_inv(k)
                a, b = int(res[i, j]), int(res[i, j + 1])
                c, d = int(res[i + 1, j]), int(res[i + 1, j + 1])
                a2, b2 = self._mat2x2_mul(M, a, b)
                c2, d2 = self._mat2x2_mul(M, c, d)
                col0_top, col0_bot = self._mat2x2_mul(M, a2, c2)
                col1_top, col1_bot = self._mat2x2_mul(M, b2, d2)
                res[i, j] = col0_top
                res[i + 1, j] = col0_bot
                res[i, j + 1] = col1_top
                res[i + 1, j + 1] = col1_bot
        return res

    def block_unmix(self, img: np.ndarray, chaos_seq: np.ndarray) -> np.ndarray:
        h, w = img.shape
        res = img.copy().astype(np.uint8)
        blocks_w = w // 2
        blocks_h = h // 2
        for bi in range(blocks_h):
            for bj in range(blocks_w):
                i = 2 * bi
                j = 2 * bj
                idx = (bi * blocks_w + bj) % len(chaos_seq)
                k = self._make_unimodular_k(chaos_seq[idx])
                M, Minv = self._build_M_and_inv(k)
                a, b = int(res[i, j]), int(res[i, j + 1])
                c, d = int(res[i + 1, j]), int(res[i + 1, j + 1])
                a2, c2 = self._mat2x2_mul(Minv, a, c)
                b2, d2 = self._mat2x2_mul(Minv, b, d)
                a3, b3 = self._mat2x2_mul(Minv, a2, b2)
                c3, d3 = self._mat2x2_mul(Minv, c2, d2)
                res[i, j] = a3
                res[i, j + 1] = b3
                res[i + 1, j] = c3
                res[i + 1, j + 1] = d3
        return res

    def elliptic_curve_key_generation(self, size: int) -> np.ndarray:
        rng = np.random.default_rng(self.chaos_params['seed'])
        keys = np.empty(size, dtype=np.uint8)
        for i in range(size):
            hv = hashlib.sha256(f"{i}:{self.chaos_params['x0']}:{self.chaos_params['y0']}".encode()).digest()
            keys[i] = (hv[i % 32] ^ rng.integers(0, 256, dtype=np.uint8)).item()
        return keys

    def encrypt_channel(self, channel: np.ndarray, chaos_seq: np.ndarray, perm_indices: np.ndarray) -> np.ndarray:
        work = channel.copy().astype(np.uint8)
        work = work.ravel()[perm_indices].reshape(work.shape)
        dna_seq = self.dna_encode(work)
        order = np.argsort(chaos_seq[:len(dna_seq)], kind='mergesort')
        shuffled_dna = [dna_seq[i] for i in order]
        work = self.dna_decode(shuffled_dna, work.shape)
        work = self.block_mix(work, chaos_seq)
        keys = self.elliptic_curve_key_generation(work.size)
        encrypted = np.bitwise_xor(work.ravel(), keys).reshape(work.shape).astype(np.uint8)
        return encrypted, order

    def decrypt_channel(self, encrypted_channel: np.ndarray, chaos_seq: np.ndarray,
                       perm_indices: np.ndarray, dna_order: np.ndarray) -> np.ndarray:
        keys = self.elliptic_curve_key_generation(encrypted_channel.size)
        work = np.bitwise_xor(encrypted_channel.ravel(), keys).reshape(encrypted_channel.shape).astype(np.uint8)
        work = self.block_unmix(work, chaos_seq)
        dna_seq = self.dna_encode(work)
        original_dna = ['A'] * len(dna_seq)
        for i, idx in enumerate(dna_order):
            original_dna[int(idx)] = dna_seq[i]
        work = self.dna_decode(original_dna, encrypted_channel.shape)
        inv_perm = np.argsort(perm_indices, kind='mergesort')
        work = work.ravel()[inv_perm].reshape(encrypted_channel.shape)
        return work.astype(np.uint8)

    def encrypt_image(self, image: np.ndarray) -> Tuple[np.ndarray, Dict]:
        if image.ndim == 2:
            image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)
        h, w, c = image.shape
        chaos_seq = self.generate_chaotic_sequence(h * w * 4)
        perm_indices = self.fractal_permutation(image[:, :, 0])
        encrypted_channels = []
        dna_orders = []
        for ch in range(c):
            enc_ch, order = self.encrypt_channel(image[:, :, ch], chaos_seq, perm_indices)
            encrypted_channels.append(enc_ch)
            dna_orders.append(order)
        encrypted = np.stack(encrypted_channels, axis=2)
        params = {
            'perm_indices': perm_indices,
            'dna_orders': dna_orders,
            'chaos_seq': chaos_seq,
            'original_shape': image.shape,
        }
        return encrypted, params

    def decrypt_image(self, encrypted_image: np.ndarray, params: Dict) -> np.ndarray:
        chaos_seq = params['chaos_seq']
        perm_indices = params['perm_indices']
        dna_orders = params['dna_orders']
        h, w, c = encrypted_image.shape
        decrypted_channels = []
        for ch in range(c):
            dec_ch = self.decrypt_channel(encrypted_image[:, :, ch], chaos_seq,
                                         perm_indices, dna_orders[ch])
            decrypted_channels.append(dec_ch)
        decrypted = np.stack(decrypted_channels, axis=2)
        return decrypted.astype(np.uint8)


# ==================== ATTACK FUNCTIONS ====================

def apply_gaussian_noise(image: np.ndarray, mean: float = 0, sigma: float = 10) -> np.ndarray:
    """Apply Gaussian noise to image"""
    noise = np.random.normal(mean, sigma, image.shape)
    noisy = image.astype(np.float64) + noise
    noisy = np.clip(noisy, 0, 255).astype(np.uint8)
    return noisy

def apply_salt_pepper_noise(image: np.ndarray, salt_prob: float = 0.01, pepper_prob: float = 0.01) -> np.ndarray:
    """Apply salt and pepper noise"""
    noisy = image.copy()
    # Salt noise
    salt_mask = np.random.random(image.shape) < salt_prob
    noisy[salt_mask] = 255
    # Pepper noise
    pepper_mask = np.random.random(image.shape) < pepper_prob
    noisy[pepper_mask] = 0
    return noisy

def apply_speckle_noise(image: np.ndarray, variance: float = 0.1) -> np.ndarray:
    """Apply speckle (multiplicative) noise"""
    noise = np.random.randn(*image.shape) * variance
    noisy = image.astype(np.float64) * (1 + noise)
    noisy = np.clip(noisy, 0, 255).astype(np.uint8)
    return noisy

def apply_jpeg_compression(image: np.ndarray, quality: int = 50) -> np.ndarray:
    """Apply JPEG compression"""
    # Convert to PIL Image
    if len(image.shape) == 3:
        pil_img = Image.fromarray(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    else:
        pil_img = Image.fromarray(image)

    # Save to bytes with compression
    buffer = BytesIO()
    pil_img.save(buffer, format='JPEG', quality=quality)
    buffer.seek(0)

    # Load back
    compressed_img = Image.open(buffer)
    compressed_array = np.array(compressed_img)

    if len(image.shape) == 3:
        compressed_array = cv2.cvtColor(compressed_array, cv2.COLOR_RGB2BGR)

    return compressed_array

def apply_brightness_adjustment(image: np.ndarray, factor: float = 1.5) -> np.ndarray:
    """Adjust brightness by a factor"""
    adjusted = image.astype(np.float64) * factor
    adjusted = np.clip(adjusted, 0, 255).astype(np.uint8)
    return adjusted

def apply_contrast_adjustment(image: np.ndarray, factor: float = 1.5) -> np.ndarray:
    """Adjust contrast by a factor"""
    mean = np.mean(image)
    adjusted = (image.astype(np.float64) - mean) * factor + mean
    adjusted = np.clip(adjusted, 0, 255).astype(np.uint8)
    return adjusted

def apply_blur(image: np.ndarray, kernel_size: int = 5) -> np.ndarray:
    """Apply Gaussian blur"""
    return cv2.GaussianBlur(image, (kernel_size, kernel_size), 0)

def apply_rotation(image: np.ndarray, angle: float = 5.0) -> np.ndarray:
    """Apply rotation"""
    h, w = image.shape[:2]
    center = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D(center, angle, 1.0)
    rotated = cv2.warpAffine(image, M, (w, h), borderMode=cv2.BORDER_REPLICATE)
    return rotated

def apply_cropping(image: np.ndarray, crop_percent: float = 0.1) -> np.ndarray:
    """Crop and restore to original size"""
    h, w = image.shape[:2]
    crop_h = int(h * crop_percent)
    crop_w = int(w * crop_percent)
    cropped = image[crop_h:h-crop_h, crop_w:w-crop_w]
    restored = cv2.resize(cropped, (w, h))
    return restored


# ==================== ANALYSIS FUNCTIONS ====================

def calculate_psnr(original: np.ndarray, modified: np.ndarray) -> float:
    """Calculate Peak Signal-to-Noise Ratio"""
    mse = np.mean((original.astype(np.float64) - modified.astype(np.float64)) ** 2)
    if mse == 0:
        return float('inf')
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))
    return float(psnr)

def calculate_ssim(original: np.ndarray, modified: np.ndarray) -> float:
    """Calculate Structural Similarity Index (simplified)"""
    C1 = (0.01 * 255) ** 2
    C2 = (0.03 * 255) ** 2

    orig = original.astype(np.float64)
    mod = modified.astype(np.float64)

    mu1 = cv2.GaussianBlur(orig, (11, 11), 1.5)
    mu2 = cv2.GaussianBlur(mod, (11, 11), 1.5)

    mu1_sq = mu1 ** 2
    mu2_sq = mu2 ** 2
    mu1_mu2 = mu1 * mu2

    sigma1_sq = cv2.GaussianBlur(orig ** 2, (11, 11), 1.5) - mu1_sq
    sigma2_sq = cv2.GaussianBlur(mod ** 2, (11, 11), 1.5) - mu2_sq
    sigma12 = cv2.GaussianBlur(orig * mod, (11, 11), 1.5) - mu1_mu2

    ssim_map = ((2 * mu1_mu2 + C1) * (2 * sigma12 + C2)) / \
               ((mu1_sq + mu2_sq + C1) * (sigma1_sq + sigma2_sq + C2))

    return float(np.mean(ssim_map))


# ==================== ROBUSTNESS TESTING ====================

def test_robustness(original_image: np.ndarray, encrypted_image: np.ndarray,
                    params: Dict, encryptor: AdvancedImageEncryption):
    """Test encryption robustness against various attacks"""

    print("="*80)
    print(" "*25 + "ROBUSTNESS TESTING")
    print("="*80)

    attacks = {
        'Gaussian Noise (σ=10)': lambda img: apply_gaussian_noise(img, 0, 10),
        'Gaussian Noise (σ=25)': lambda img: apply_gaussian_noise(img, 0, 25),
        'Salt & Pepper (1%)': lambda img: apply_salt_pepper_noise(img, 0.01, 0.01),
        'Salt & Pepper (5%)': lambda img: apply_salt_pepper_noise(img, 0.05, 0.05),
        'Speckle Noise': lambda img: apply_speckle_noise(img, 0.1),
        'JPEG Q=90': lambda img: apply_jpeg_compression(img, 90),
        'JPEG Q=70': lambda img: apply_jpeg_compression(img, 70),
        'JPEG Q=50': lambda img: apply_jpeg_compression(img, 50),
        'JPEG Q=30': lambda img: apply_jpeg_compression(img, 30),
        'Brightness +50%': lambda img: apply_brightness_adjustment(img, 1.5),
        'Brightness -30%': lambda img: apply_brightness_adjustment(img, 0.7),
        'Contrast +50%': lambda img: apply_contrast_adjustment(img, 1.5),
        'Contrast -30%': lambda img: apply_contrast_adjustment(img, 0.7),
        'Gaussian Blur': lambda img: apply_blur(img, 5),
        'Rotation 5°': lambda img: apply_rotation(img, 5.0),
        'Cropping 10%': lambda img: apply_cropping(img, 0.1),
    }

    results = {}
    attacked_images = {}
    decrypted_images = {}

    for attack_name, attack_func in attacks.items():
        print(f"\nTesting: {attack_name}")
        print("-" * 80)

        try:
            # Apply attack
            attacked = attack_func(encrypted_image.copy())
            attacked_images[attack_name] = attacked

            # Attempt decryption
            decrypted = encryptor.decrypt_image(attacked, params)
            decrypted_images[attack_name] = decrypted

            # Calculate metrics
            psnr_enc = calculate_psnr(encrypted_image, attacked)
            psnr_dec = calculate_psnr(original_image, decrypted)
            ssim_dec = calculate_ssim(original_image, decrypted)

            mse = np.mean((original_image.astype(np.float64) - decrypted.astype(np.float64)) ** 2)
            bit_error_rate = np.count_nonzero(original_image != decrypted) / original_image.size * 100

            results[attack_name] = {
                'psnr_encrypted': psnr_enc,
                'psnr_decrypted': psnr_dec,
                'ssim_decrypted': ssim_dec,
                'mse': mse,
                'ber': bit_error_rate,
            }

            print(f"  Attack impact (PSNR): {psnr_enc:.2f} dB")
            print(f"  Decryption quality (PSNR): {psnr_dec:.2f} dB")
            print(f"  Decryption quality (SSIM): {ssim_dec:.4f}")
            print(f"  MSE: {mse:.2f}")
            print(f"  Bit Error Rate: {bit_error_rate:.4f}%")

        except Exception as e:
            print(f"  ❌ Error: {str(e)}")
            results[attack_name] = None

    return results, attacked_images, decrypted_images


def visualize_robustness_results(original, encrypted, results, attacked_images, decrypted_images):
    """Visualize robustness test results"""

    # Select representative attacks for visualization
    selected_attacks = [
        'Gaussian Noise (σ=25)',
        'Salt & Pepper (5%)',
        'JPEG Q=30',
        'Brightness +50%',
        'Gaussian Blur',
        'Rotation 5°'
    ]

    # Create visualization
    fig, axes = plt.subplots(3, 6, figsize=(24, 12))
    fig.suptitle('Robustness Testing: Attack Effects and Decryption Results',
                 fontsize=20, fontweight='bold', y=0.995)

    # Original and encrypted in first row
    original_rgb = cv2.cvtColor(original, cv2.COLOR_BGR2RGB)
    encrypted_rgb = cv2.cvtColor(encrypted, cv2.COLOR_BGR2RGB)

    axes[0, 0].imshow(original_rgb)
    axes[0, 0].set_title('Original\nImage', fontsize=12, fontweight='bold')
    axes[0, 0].axis('off')

    axes[0, 1].imshow(encrypted_rgb)
    axes[0, 1].set_title('Encrypted\nImage', fontsize=12, fontweight='bold')
    axes[0, 1].axis('off')

    # Hide unused slots
    for i in range(2, 6):
        axes[0, i].axis('off')

    # Display attacks and their decryptions
    for idx, attack_name in enumerate(selected_attacks):
        if attack_name in attacked_images:
            # Attacked image (row 1)
            attacked_rgb = cv2.cvtColor(attacked_images[attack_name], cv2.COLOR_BGR2RGB)
            axes[1, idx].imshow(attacked_rgb)

            if results[attack_name]:
                psnr = results[attack_name]['psnr_encrypted']
                axes[1, idx].set_title(f'{attack_name}\nPSNR: {psnr:.1f} dB',
                                      fontsize=10, fontweight='bold')
            else:
                axes[1, idx].set_title(f'{attack_name}\nFailed', fontsize=10)
            axes[1, idx].axis('off')

            # Decrypted image (row 2)
            if attack_name in decrypted_images:
                decrypted_rgb = cv2.cvtColor(decrypted_images[attack_name], cv2.COLOR_BGR2RGB)
                axes[2, idx].imshow(decrypted_rgb)

                if results[attack_name]:
                    psnr = results[attack_name]['psnr_decrypted']
                    ssim = results[attack_name]['ssim_decrypted']
                    ber = results[attack_name]['ber']
                    axes[2, idx].set_title(f'Decrypted\nPSNR: {psnr:.1f} dB\nSSIM: {ssim:.3f}\nBER: {ber:.2f}%',
                                          fontsize=9, fontweight='bold')
                else:
                    axes[2, idx].set_title('Decryption\nFailed', fontsize=10)
                axes[2, idx].axis('off')

    # Row labels
    fig.text(0.02, 0.75, 'Attacked\nEncrypted', fontsize=14, fontweight='bold',
             rotation=90, va='center')
    fig.text(0.02, 0.35, 'Decrypted\nResult', fontsize=14, fontweight='bold',
             rotation=90, va='center')

    plt.tight_layout(rect=[0.03, 0, 1, 0.99])

    # Save
    plt.savefig('robustness_testing_300dpi.png', dpi=300, bbox_inches='tight')
    print("\n✅ Visualization saved as: robustness_testing_300dpi.png")
    plt.show()

    # Create summary table
    create_summary_table(results)


def create_summary_table(results):
    """Create a summary table of all results"""

    print("\n" + "="*100)
    print(" "*35 + "ROBUSTNESS TEST SUMMARY")
    print("="*100)
    print(f"{'Attack Type':<25} {'PSNR (Enc)':<12} {'PSNR (Dec)':<12} {'SSIM (Dec)':<12} {'BER (%)':<10} {'Status'}")
    print("-"*100)

    for attack_name, metrics in results.items():
        if metrics:
            status = "✅ Pass" if metrics['ber'] < 10 else "⚠️ Poor" if metrics['ber'] < 50 else "❌ Fail"
            print(f"{attack_name:<25} {metrics['psnr_encrypted']:>10.2f} dB "
                  f"{metrics['psnr_decrypted']:>10.2f} dB "
                  f"{metrics['ssim_decrypted']:>10.4f}   "
                  f"{metrics['ber']:>9.3f}  {status}")
        else:
            print(f"{attack_name:<25} {'N/A':<12} {'N/A':<12} {'N/A':<12} {'N/A':<10} ❌ Error")

    print("="*100)

    # Calculate statistics
    valid_results = [r for r in results.values() if r is not None]
    if valid_results:
        avg_psnr_dec = np.mean([r['psnr_decrypted'] for r in valid_results])
        avg_ssim_dec = np.mean([r['ssim_decrypted'] for r in valid_results])
        avg_ber = np.mean([r['ber'] for r in valid_results])

        print(f"\nAVERAGE METRICS:")
        print(f"  PSNR (Decrypted): {avg_psnr_dec:.2f} dB")
        print(f"  SSIM (Decrypted): {avg_ssim_dec:.4f}")
        print(f"  Bit Error Rate: {avg_ber:.3f}%")
        print("\nINTERPRETATION:")
        print("  - BER < 1%:  Excellent robustness")
        print("  - BER 1-10%: Good robustness")
        print("  - BER 10-50%: Poor robustness")
        print("  - BER > 50%: Failed (encryption compromised)")


def main():
    """Main execution function"""

    # Load original image
    print("Loading images...")
    original_image = cv2.imread('/content/Test.jpg')
    if original_image is None:
        print("Error: Could not load original image")
        return

    print(f"Original image shape: {original_image.shape}")

    # Initialize encryptor
    encryptor = AdvancedImageEncryption("SecureTestPassword2024!")

    # Encrypt the image
    print("\n" + "="*80)
    print(" "*30 + "ENCRYPTION PHASE")
    print("="*80)
    encrypted_image, params = encryptor.encrypt_image(original_image)
    print("✅ Encryption completed")

    # Test decryption without attacks (baseline)
    print("\n" + "="*80)
    print(" "*28 + "BASELINE DECRYPTION")
    print("="*80)
    decrypted_baseline = encryptor.decrypt_image(encrypted_image, params)
    baseline_mse = np.mean((original_image.astype(np.float64) - decrypted_baseline.astype(np.float64)) ** 2)
    baseline_perfect = (baseline_mse == 0.0)
    print(f"Baseline MSE: {baseline_mse:.10f}")
    print(f"Perfect reconstruction: {baseline_perfect}")
    if baseline_perfect:
        print("✅ PERFECT BASELINE DECRYPTION")
    else:
        print("⚠️ Baseline has errors - encryption may have issues")

    # Run robustness tests
    results, attacked_images, decrypted_images = test_robustness(
        original_image, encrypted_image, params, encryptor
    )

    # Visualize results
    print("\n" + "="*80)
    print(" "*28 + "GENERATING VISUALIZATIONS")
    print("="*80)
    visualize_robustness_results(
        original_image, encrypted_image, results,
        attacked_images, decrypted_images
    )

    # Save individual attacked images for detailed inspection
    print("\n" + "="*80)
    print(" "*25 + "SAVING ATTACKED IMAGES")
    print("="*80)

    for attack_name, attacked_img in attacked_images.items():
        safe_name = attack_name.replace(' ', '_').replace('(', '').replace(')', '').replace('%', 'pct')
        filename = f'attacked_{safe_name}.png'
        cv2.imwrite(filename, attacked_img)
        print(f"  Saved: {filename}")

    print("\n" + "="*80)
    print(" "*25 + "ROBUSTNESS TESTING COMPLETED")
    print("="*80)

    return results, attacked_images, decrypted_images


if __name__ == "__main__":
    results, attacked_images, decrypted_images = main()

"""## Histogram Plottings"""

import cv2
import matplotlib.pyplot as plt
import numpy as np

# Read the image
image_path = "/content/original_color.png"
image = cv2.imread(image_path)

# Convert the image to RGB (OpenCV reads images in BGR by default)
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Set up high-quality figure with larger size for better readability
fig, axs = plt.subplots(1, 4, figsize=(20, 5))

# Configure matplotlib for high-quality output
plt.rcParams['font.size'] = 12
plt.rcParams['font.family'] = 'DejaVu Sans'
plt.rcParams['axes.linewidth'] = 1.5
plt.rcParams['xtick.major.width'] = 1.5
plt.rcParams['ytick.major.width'] = 1.5

# Display the original image
axs[0].imshow(image_rgb)
axs[0].axis('off')
axs[0].set_title("Original Image", fontsize=18, fontweight='bold', pad=15)
# Add border around image
for spine in axs[0].spines.values():
    spine.set_edgecolor('black')
    spine.set_linewidth(2)
    spine.set_visible(True)

# Colors for histograms
colors = ('r', 'g', 'b')
channel_names = ['Red Channel', 'Green Channel', 'Blue Channel']
color_codes = ['#E74C3C', '#27AE60', '#3498DB']  # Professional colors

# Plot histograms for each color channel
for i, (color, channel_name, color_code) in enumerate(zip(colors, channel_names, color_codes)):
    # Calculate histogram
    histogram = cv2.calcHist([image], [i], None, [256], [0, 256])

    # Plot with improved styling
    axs[i + 1].bar(range(256), histogram.flatten(),
                   color=color_code, alpha=0.8, width=1.0,
                   edgecolor='none')

    # Styling
    axs[i + 1].set_title(channel_name, fontsize=18, fontweight='bold', pad=15)
    axs[i + 1].set_xlim(0, 255)
    axs[i + 1].set_xlabel("Pixel Intensity", fontsize=14, fontweight='bold')
    axs[i + 1].set_ylabel("Frequency", fontsize=14, fontweight='bold')

    # Add grid for better readability
    axs[i + 1].grid(True, alpha=0.3, linestyle='--', linewidth=0.8)
    axs[i + 1].set_axisbelow(True)

    # Improve tick labels
    axs[i + 1].tick_params(labelsize=11)


# Adjust layout
plt.tight_layout()

# Save with 300 DPI for publication quality
output_filename = 'histogram_analysis_300dpi.png'
plt.savefig(output_filename, dpi=300, bbox_inches='tight',
            facecolor='white', edgecolor='none')
print(f"✅ High-resolution image saved as: {output_filename}")
print(f"   Resolution: 300 DPI")
print(f"   Format: PNG")

# Display the plot
plt.show()

# Optionally, create a version for the encrypted image as well
print("\n" + "="*60)
print("Creating histogram for ENCRYPTED image...")
print("="*60)

encrypted_path = "/content/encrypted_color.png"
try:
    encrypted_image = cv2.imread(encrypted_path)
    encrypted_rgb = cv2.cvtColor(encrypted_image, cv2.COLOR_BGR2RGB)

    # Create figure for encrypted image
    fig2, axs2 = plt.subplots(1, 4, figsize=(20, 5))

    # Display encrypted image
    axs2[0].imshow(encrypted_rgb)
    axs2[0].axis('off')
    axs2[0].set_title("Encrypted Image", fontsize=18, fontweight='bold', pad=15)
    for spine in axs2[0].spines.values():
        spine.set_edgecolor('black')
        spine.set_linewidth(2)
        spine.set_visible(True)

    # Plot histograms for encrypted image
    for i, (color, channel_name, color_code) in enumerate(zip(colors, channel_names, color_codes)):
        histogram = cv2.calcHist([encrypted_image], [i], None, [256], [0, 256])

        axs2[i + 1].bar(range(256), histogram.flatten(),
                       color=color_code, alpha=0.8, width=1.0,
                       edgecolor='none')

        axs2[i + 1].set_title(channel_name, fontsize=18, fontweight='bold', pad=15)
        axs2[i + 1].set_xlim(0, 255)
        axs2[i + 1].set_xlabel("Pixel Intensity", fontsize=14, fontweight='bold')
        axs2[i + 1].set_ylabel("Frequency", fontsize=14, fontweight='bold')
        axs2[i + 1].grid(True, alpha=0.3, linestyle='--', linewidth=0.8)
        axs2[i + 1].set_axisbelow(True)
        axs2[i + 1].tick_params(labelsize=11)


    plt.tight_layout()

    # Save encrypted image histograms
    encrypted_output = 'encrypted_histogram_300dpi.png'
    plt.savefig(encrypted_output, dpi=300, bbox_inches='tight',
                facecolor='white', edgecolor='none')
    print(f"✅ Encrypted histogram saved as: {encrypted_output}")

    encrypted_pdf = 'encrypted_histogram_vector.pdf'
    plt.savefig(encrypted_pdf, format='pdf', bbox_inches='tight',
                facecolor='white', edgecolor='none')
    print(f"✅ Vector format saved as: {encrypted_pdf}")

    plt.show()

except:
    print("⚠️  Encrypted image not found. Skipping encrypted histogram.")

print("\n" + "="*60)
print("All high-resolution images saved successfully!")
print("="*60)

"""## Correlation Plots"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import pearsonr

# Configure matplotlib for high-quality output
plt.rcParams['font.size'] = 11
plt.rcParams['font.family'] = 'DejaVu Sans'
plt.rcParams['axes.linewidth'] = 1.5
plt.rcParams['xtick.major.width'] = 1.5
plt.rcParams['ytick.major.width'] = 1.5

def calculate_correlation(x, y):
    """Calculate Pearson correlation coefficient"""
    correlation, _ = pearsonr(x, y)
    return correlation

def extract_pairs(image, direction, sample_size=5000):
    """
    Extract pixel pairs for correlation analysis
    sample_size: number of points to plot (for better visualization)
    """
    h, w = image.shape
    if direction == 'horizontal':
        x = image[:, :-1].flatten()
        y = image[:, 1:].flatten()
    elif direction == 'vertical':
        x = image[:-1, :].flatten()
        y = image[1:, :].flatten()
    elif direction == 'diagonal':
        x = image[:-1, :-1].flatten()
        y = image[1:, 1:].flatten()

    # Sample points for plotting (to avoid overcrowding)
    if len(x) > sample_size:
        indices = np.random.choice(len(x), sample_size, replace=False)
        x_sample = x[indices]
        y_sample = y[indices]
    else:
        x_sample = x
        y_sample = y

    # Calculate correlation on full data
    correlation = calculate_correlation(x, y)

    return x_sample, y_sample, correlation, len(x)

def create_correlation_plot(image_path, title_prefix, output_prefix):
    """Create correlation plots for an image"""

    # Load the image in grayscale
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    if image is None:
        print(f"Error: Could not load image from {image_path}")
        return

    print(f"Processing: {title_prefix}")
    print(f"Image shape: {image.shape}")

    # Define directions and colors
    directions = ['horizontal', 'vertical', 'diagonal']
    direction_labels = ['Horizontal', 'Vertical', 'Diagonal']
    colors = ['#E74C3C', '#27AE60', '#3498DB']  # Red, Green, Blue

    # Create figure with subplots
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))
    fig.suptitle(f'{title_prefix} - Correlation Analysis',
                 fontsize=20, fontweight='bold', y=1.02)

    correlations = []

    for i, (direction, label, color) in enumerate(zip(directions, direction_labels, colors)):
        ax = axes[i]

        # Extract pixel pairs and calculate correlation
        x, y, correlation, total_pairs = extract_pairs(image, direction, sample_size=5000)
        correlations.append(correlation)

        print(f"  {label}: r = {correlation:.6f} (using {total_pairs:,} pixel pairs)")

        # Create scatter plot
        ax.scatter(x, y, s=1.5, c=color, alpha=0.4, edgecolors='none')

        # Add diagonal reference line
        ax.plot([0, 255], [0, 255], 'k--', linewidth=1.5, alpha=0.5, label='y=x')

        # Styling
        ax.set_title(f'{label} Direction', fontsize=16, fontweight='bold', pad=12)
        ax.set_xlabel('Pixel Intensity at Position (i, j)', fontsize=13, fontweight='bold')
        ax.set_ylabel('Pixel Intensity at Adjacent Position', fontsize=13, fontweight='bold')
        ax.set_xlim(-5, 260)
        ax.set_ylim(-5, 260)
        ax.set_aspect('equal')
        ax.grid(True, alpha=0.3, linestyle='--', linewidth=0.8)
        ax.set_axisbelow(True)
        ax.tick_params(labelsize=11)

        # Add statistics text box
        stats_text = (
            f'Correlation (r): {correlation:.6f}\n'
            f'r²: {correlation**2:.6f}\n'
            f'Total pairs: {total_pairs:,}\n'
            f'Samples shown: {len(x):,}'
        )

        # Color the text box based on correlation strength
        if abs(correlation) < 0.1:
            box_color = '#D5F4E6'  # Light green (good encryption)
            strength = 'Weak (Good)'
        elif abs(correlation) < 0.3:
            box_color = '#FFF3CD'  # Light yellow
            strength = 'Moderate'
        else:
            box_color = '#F8D7DA'  # Light red (strong correlation)
            strength = 'Strong (Poor)'

        stats_text += f'\nStrength: {strength}'

        ax.text(0.97, 0.03, stats_text,
                transform=ax.transAxes,
                fontsize=10,
                verticalalignment='bottom',
                horizontalalignment='right',
                bbox=dict(boxstyle='round', facecolor=box_color,
                         alpha=0.9, edgecolor='black', linewidth=1.5),
                family='monospace')

        # Add legend
        ax.legend(loc='upper left', fontsize=10, framealpha=0.9)

    plt.tight_layout()

    # Save high-resolution PNG
    png_output = f'{output_prefix}_correlation_300dpi.png'
    plt.savefig(png_output, dpi=300, bbox_inches='tight',
                facecolor='white', edgecolor='none')
    print(f"✅ Saved: {png_output}")

    # Save vector PDF
    pdf_output = f'{output_prefix}_correlation_vector.pdf'
    plt.savefig(pdf_output, format='pdf', bbox_inches='tight',
                facecolor='white', edgecolor='none')
    print(f"✅ Saved: {pdf_output}")

    plt.show()

    # Print summary
    print(f"\nCorrelation Summary for {title_prefix}:")
    print(f"  Horizontal: {correlations[0]:.6f}")
    print(f"  Vertical:   {correlations[1]:.6f}")
    print(f"  Diagonal:   {correlations[2]:.6f}")
    print(f"  Average:    {np.mean(correlations):.6f}")
    print()

    return correlations


def create_comparison_plot(orig_path, enc_path):
    """Create side-by-side comparison of original and encrypted correlations"""

    print("="*70)
    print(" "*20 + "COMPARISON MODE")
    print("="*70)

    # Load images
    orig_img = cv2.imread(orig_path, cv2.IMREAD_GRAYSCALE)
    enc_img = cv2.imread(enc_path, cv2.IMREAD_GRAYSCALE)

    if orig_img is None or enc_img is None:
        print("Error: Could not load one or both images")
        return

    directions = ['horizontal', 'vertical', 'diagonal']
    direction_labels = ['Horizontal', 'Vertical', 'Diagonal']
    colors_orig = ['#E74C3C', '#27AE60', '#3498DB']
    colors_enc = ['#C0392B', '#229954', '#2874A6']

    # Create figure
    fig, axes = plt.subplots(2, 3, figsize=(18, 12))
    fig.suptitle('Correlation Analysis Comparison\nOriginal vs Encrypted',
                 fontsize=22, fontweight='bold', y=0.995)

    orig_corrs = []
    enc_corrs = []

    for i, (direction, label) in enumerate(zip(directions, direction_labels)):
        # Original image (top row)
        ax_orig = axes[0, i]
        x_orig, y_orig, corr_orig, total_orig = extract_pairs(orig_img, direction, sample_size=5000)
        orig_corrs.append(corr_orig)

        ax_orig.scatter(x_orig, y_orig, s=1.5, c=colors_orig[i], alpha=0.4, edgecolors='none')
        ax_orig.plot([0, 255], [0, 255], 'k--', linewidth=1.5, alpha=0.5)
        ax_orig.set_title(f'Original - {label}', fontsize=15, fontweight='bold', pad=10)
        ax_orig.set_xlabel('Pixel Intensity (i, j)', fontsize=12, fontweight='bold')
        ax_orig.set_ylabel('Adjacent Pixel', fontsize=12, fontweight='bold')
        ax_orig.set_xlim(-5, 260)
        ax_orig.set_ylim(-5, 260)
        ax_orig.set_aspect('equal')
        ax_orig.grid(True, alpha=0.3, linestyle='--', linewidth=0.8)
        ax_orig.tick_params(labelsize=10)

        stats_orig = f'r = {corr_orig:.6f}\nr² = {corr_orig**2:.6f}'
        ax_orig.text(0.97, 0.03, stats_orig,
                    transform=ax_orig.transAxes,
                    fontsize=11,
                    verticalalignment='bottom',
                    horizontalalignment='right',
                    bbox=dict(boxstyle='round', facecolor='#F8D7DA',
                             alpha=0.9, edgecolor='black', linewidth=1.5),
                    family='monospace')

        # Encrypted image (bottom row)
        ax_enc = axes[1, i]
        x_enc, y_enc, corr_enc, total_enc = extract_pairs(enc_img, direction, sample_size=5000)
        enc_corrs.append(corr_enc)

        ax_enc.scatter(x_enc, y_enc, s=1.5, c=colors_enc[i], alpha=0.4, edgecolors='none')
        ax_enc.plot([0, 255], [0, 255], 'k--', linewidth=1.5, alpha=0.5)
        ax_enc.set_title(f'Encrypted - {label}', fontsize=15, fontweight='bold', pad=10)
        ax_enc.set_xlabel('Pixel Intensity (i, j)', fontsize=12, fontweight='bold')
        ax_enc.set_ylabel('Adjacent Pixel', fontsize=12, fontweight='bold')
        ax_enc.set_xlim(-5, 260)
        ax_enc.set_ylim(-5, 260)
        ax_enc.set_aspect('equal')
        ax_enc.grid(True, alpha=0.3, linestyle='--', linewidth=0.8)
        ax_enc.tick_params(labelsize=10)

        stats_enc = f'r = {corr_enc:.6f}\nr² = {corr_enc**2:.6f}'
        ax_enc.text(0.97, 0.03, stats_enc,
                   transform=ax_enc.transAxes,
                   fontsize=11,
                   verticalalignment='bottom',
                   horizontalalignment='right',
                   bbox=dict(boxstyle='round', facecolor='#D5F4E6',
                            alpha=0.9, edgecolor='black', linewidth=1.5),
                   family='monospace')

    plt.tight_layout()

    # Save outputs
    png_output = 'correlation_comparison_300dpi.png'
    plt.savefig(png_output, dpi=300, bbox_inches='tight',
                facecolor='white', edgecolor='none')
    print(f"✅ Saved: {png_output}")

    pdf_output = 'correlation_comparison_vector.pdf'
    plt.savefig(pdf_output, format='pdf', bbox_inches='tight',
                facecolor='white', edgecolor='none')
    print(f"✅ Saved: {pdf_output}")

    plt.show()

    # Print detailed comparison
    print("\n" + "="*70)
    print("CORRELATION COMPARISON SUMMARY")
    print("="*70)
    print(f"{'Direction':<15} {'Original':>12} {'Encrypted':>12} {'Reduction':>12}")
    print("-"*70)
    for i, label in enumerate(direction_labels):
        reduction = (1 - abs(enc_corrs[i])/abs(orig_corrs[i])) * 100
        print(f"{label:<15} {orig_corrs[i]:>12.6f} {enc_corrs[i]:>12.6f} {reduction:>11.2f}%")
    print("-"*70)
    avg_orig = np.mean([abs(c) for c in orig_corrs])
    avg_enc = np.mean([abs(c) for c in enc_corrs])
    avg_reduction = (1 - avg_enc/avg_orig) * 100
    print(f"{'Average':<15} {avg_orig:>12.6f} {avg_enc:>12.6f} {avg_reduction:>11.2f}%")
    print("="*70)


# Main execution
if __name__ == "__main__":
    print("="*70)
    print(" "*15 + "CORRELATION ANALYSIS - 300 DPI")
    print("="*70)
    print()

    # Process original image
    try:
        print("Processing ORIGINAL image...")
        create_correlation_plot(
            '/content/original_color.png',
            'Original Image',
            'original'
        )
    except Exception as e:
        print(f"Error processing original image: {e}")

    print()

    # Process encrypted image
    try:
        print("Processing ENCRYPTED image...")
        create_correlation_plot(
            '/content/encrypted_color.png',
            'Encrypted Image',
            'encrypted'
        )
    except Exception as e:
        print(f"Error processing encrypted image: {e}")

    print()

    # Create comparison plot
    try:
        create_comparison_plot(
            '/content/original_color.png',
            '/content/encrypted_color.png'
        )
    except Exception as e:
        print(f"Error creating comparison plot: {e}")

    print("\n" + "="*70)
    print(" "*20 + "ALL PLOTS COMPLETED!")
    print("="*70)

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image in grayscale
image = cv2.imread('/content/encrypted_image.png', cv2.IMREAD_GRAYSCALE)

# Define pixel pairs for scatter plot
def extract_pairs(image, direction):
    h, w = image.shape
    if direction == 'horizontal':
        x = image[:, :-1].flatten()
        y = image[:, 1:].flatten()
    elif direction == 'vertical':
        x = image[:-1, :].flatten()
        y = image[1:, :].flatten()
    elif direction == 'diagonal':
        x = image[:-1, :-1].flatten()
        y = image[1:, 1:].flatten()
    return x, y

# Create scatter plots
directions = ['horizontal', 'vertical', 'diagonal']
colors = ['red', 'green', 'blue']

plt.figure(figsize=(15, 5))
for i, direction in enumerate(directions):
    x, y = extract_pairs(image, direction)
    plt.subplot(1, 3, i + 1)
    plt.scatter(x, y, s=1, c=colors[i], alpha=0.5)
    plt.title(direction.capitalize(), fontsize=16)
    plt.xlabel('Pixel Intensity (x)', fontsize=12)
    plt.ylabel('Pixel Intensity (y)', fontsize=12)
    plt.axis('equal')

plt.tight_layout()
plt.show()

"""## Correlation coefficient and Information Entropy calculation"""

import cv2
import numpy as np
from scipy.stats import entropy

def calculate_correlation(image, direction):
    """
    Calculate correlation coefficient for the given direction in the image.
    """
    if direction == "horizontal":
        x = image[:, :-1].flatten()
        y = image[:, 1:].flatten()
    elif direction == "vertical":
        x = image[:-1, :].flatten()
        y = image[1:, :].flatten()
    elif direction == "diagonal":
        x = image[:-1, :-1].flatten()
        y = image[1:, 1:].flatten()
    else:
        raise ValueError("Direction must be 'horizontal', 'vertical', or 'diagonal'.")

    correlation = np.corrcoef(x, y)[0, 1]
    return correlation

def calculate_entropy(image):
    """
    Calculate information entropy of the image.
    """
    histogram, _ = np.histogram(image.flatten(), bins=256, range=(0, 256), density=True)
    histogram = histogram[histogram > 0]  # Exclude zero probabilities
    return entropy(histogram, base=2)

# Load image (grayscale)
image_path = "/content/encrypted_image.png"  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Calculate correlation coefficients
correlation_horizontal = calculate_correlation(image, "horizontal")
correlation_vertical = calculate_correlation(image, "vertical")
correlation_diagonal = calculate_correlation(image, "diagonal")

# Calculate entropy
image_entropy = calculate_entropy(image)

# Print results
print("Horizontal Correlation:", correlation_horizontal)
print("Vertical Correlation:", correlation_vertical)
print("Diagonal Correlation:", correlation_diagonal)
print("Information Entropy:", image_entropy)